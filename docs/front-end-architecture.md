# Otlob Frontend Architecture

### **Section 1: Template and Framework Selection**

This document will use the standard project structure generated by the `flutter create` command as its foundation. This provides a well-understood, conventional starting point for the application. No external or third-party starter templates will be used.

#### **Change Log**

| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| 26 Sep 2025 | 1.0 | Initial draft of Frontend Architecture document. | Winston, Architect |

---
### **Section 2: Frontend Tech Stack**

| Category | Technology | Version | Purpose | Rationale |
| :--- | :--- | :--- | :--- | :--- |
| Framework | Flutter | Latest Stable | Core application framework | Project requirement. Provides cross-platform native performance. |
| State Management | `flutter_bloc` | Latest | Manages application state | Promotes clean architecture by separating UI from business logic. Highly scalable and testable. |
| Routing | `go_router` | Latest | Handles navigation and deep linking | Maintained by the Flutter team. Excellent support for deep linking. |
| API Integration | `dio` | Latest | HTTP client for backend communication | Powerful and flexible, with support for interceptors. |
| Testing | `flutter_test` / `integration_test` | SDK | Unit, widget, and integration testing | Standard, built-in testing frameworks for Flutter. |
| PDF Generation | `pdf` | Latest | Creates downloadable PDF receipts | A powerful library for generating PDF documents in Dart. |
| Local Storage | `shared_preferences` | Latest | Persists simple key-value data | For storing auth token and user preferences. |
| Service Locator | `get_it` | Latest | Dependency injection | Decouples classes and allows for easy mocking in tests. |

---
### **Section 3: Project Structure (Revised)**

```plaintext
otlob/
|
|-- assets/
|   |-- images/
|   |-- fonts/
|
|-- lib/
|   |
|   |-- api/
|   |   |-- dio_client.dart
|   |   |-- interceptors/
|   |
|   |-- app/
|   |   |-- di.dart
|   |   |-- router.dart
|   |   |-- theme.dart
|   |
|   |-- core/
|   |   |-- constants/
|   |   |-- utils/
|   |   |-- l10n/
|   |
|   |-- data/
|   |   |-- datasources/
|   |   |   |-- auth_remote_datasource.dart
|   |   |
|   |   |-- models/
|   |   |
|   |   |-- repositories/
|   |       |-- auth_repository_impl.dart
|   |
|   |-- domain/
|   |   |-- repositories/
|   |   |   |-- auth_repository.dart
|   |   |
|   |   |-- usecases/
|   |
|   |-- features/
|   |   |-- ... (feature modules)
|   |
|   |-- shared_widgets/
|   |   |-- primary_button.dart
|   |   |-- restaurant_card.dart
|   |
|   |-- main.dart
|
|-- pubspec.yaml
```

---
### **Section 4: Component Standards (Revised)**

#### **Component Template**
```dart
import 'package:flutter/material.dart';

/// A card that displays a summary of a restaurant.
class RestaurantCard extends StatelessWidget {
  /// The name of the restaurant.
  final String name;

  /// The URL for the restaurant's primary image.
  final String imageUrl;

  /// {@macro restaurant_card}
  const RestaurantCard({
    super.key,
    required this.name,
    required this.imageUrl,
  });

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    return Column(
      children: [
        Image.network(imageUrl),
        Text(name, style: textTheme.titleMedium),
      ],
    );
  }
}
```

#### **Naming Conventions**
| Element Type | Convention | Example |
| :--- | :--- | :--- |
| Files (Public) | `snake_case.dart` | `restaurant_card.dart` |
| Files (Private) | `_snake_case.dart` | `_private_helper.dart` |
| Classes / Widgets | `PascalCase` | `RestaurantCard` |
| Test Files | `..._test.dart` | `restaurant_card_test.dart` |
| Screens / Pages | `..._screen.dart` | `home_screen.dart` |
| BLoCs / Cubits | `..._bloc.dart` | `home_bloc.dart` |
| Repositories (Abstract) | `..._repository.dart` | `auth_repository.dart` |
| Repositories (Impl) | `..._repository_impl.dart` | `auth_repository_impl.dart` |
| Data Sources | `..._datasource.dart` | `auth_remote_datasource.dart` |

#### **State Management**
*   **Default:** Use **Cubit** for simple state management.
*   **Advanced:** Use **BLoC** for complex scenarios with events.

#### **Styling & Theming**
*   **Centralized Theme:** All styles will be defined in `lib/app/theme.dart`.
*   **No Hardcoded Values:** Widgets must reference the theme via `Theme.of(context)`.

#### **Linting & Enforcement**
*   **Enforcement:** Standards will be enforced automatically using `flutter_lints` and potentially `very_good_analysis`.

#### **Documentation**
*   **Public APIs:** All public classes and methods must be documented using DartDoc (`///`).

---
### **Section 5: State Management Architecture (Revised)**

#### **Guiding Principles**
*   **Bloc vs. Cubit:** Use **Cubit** for simple state management. Use **BLoC** for more complex scenarios with a variety of inputs.
*   **Immutability:** All state classes must be immutable.
*   **Testing:** Every BLoC and Cubit must have a corresponding test file.

#### **Error Handling Model**
```dart
import 'package:equatable/equatable.dart';

abstract class Failure extends Equatable {
  final String message;
  final int? statusCode;

  const Failure(this.message, {this.statusCode});

  @override
  List<Object?> get props => [message, statusCode];
}

class ServerFailure extends Failure {
  const ServerFailure(super.message, {super.statusCode});
}
```

#### **BLoC/Cubit File Structure**
```plaintext
features/home/bloc/
|-- home_bloc.dart
|-- home_event.dart
|-- home_state.dart
```

#### **State Management Template (BLoC)**
**`home_state.dart` (Revised)**
```dart
part of 'home_bloc.dart';

abstract class HomeState extends Equatable {
  const HomeState();
  @override
  List<Object> get props => [];
}

class HomeInitial extends HomeState {}
class HomeLoading extends HomeState {}
class HomeRefreshing extends HomeState {}
class HomeEmpty extends HomeState {}

class HomeLoaded extends HomeState {
  final List<Restaurant> restaurants;
  const HomeLoaded(this.restaurants);
  @override
  List<Object> get props => [restaurants];
}

class HomeError extends HomeState {
  final Failure failure;
  const HomeError(this.failure);
  @override
  List<Object> get props => [failure];
}
```

**`home_bloc.dart` (Revised with DI and improved logic)**
```dart
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';

part 'home_event.dart';
part 'home_state.dart';

class HomeBloc extends Bloc<HomeEvent, HomeState> {
  final RestaurantRepository _restaurantRepository;

  HomeBloc({required RestaurantRepository restaurantRepository})
      : _restaurantRepository = restaurantRepository,
        super(HomeInitial()) {
    on<FetchRestaurants>(_onFetchRestaurants);
  }

  Future<void> _onFetchRestaurants(
    FetchRestaurants event,
    Emitter<HomeState> emit,
  ) async {
    if (state is HomeLoaded) {
      emit(HomeRefreshing());
    } else {
      emit(HomeLoading());
    }
    
    try {
      final restaurants = await _restaurantRepository.getRestaurants();
      if (restaurants.isEmpty) {
        emit(HomeEmpty());
      } else {
        emit(HomeLoaded(restaurants));
      }
    } on ServerException catch (e) {
      emit(HomeError(ServerFailure(e.message, statusCode: e.statusCode)));
    }
  }
}
```

#### **Observability**
*   **BlocObserver:** A global `BlocObserver` will be configured at the root of the application for logging transitions and errors during development.

---
### **Section 6: API Integration (Revised)**

#### **API Client Configuration (`api/dio_client.dart`)**
```dart
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';

class DioClient {
  static Dio getInstance() {
    final dio = Dio(
      BaseOptions(
        baseUrl: 'https://api.otlob.com/v1',
        connectTimeout: const Duration(seconds: 15),
        receiveTimeout: const Duration(seconds: 30),
      ),
    );

    if (kDebugMode) {
      dio.interceptors.add(LogInterceptor(responseBody: true, requestBody: true));
    }
    dio.interceptors.add(AuthInterceptor(/* Inject TokenStorage service here */));
    dio.interceptors.add(ErrorInterceptor(/* Inject services needed for token refresh */));

    return dio;
  }
}

class AuthInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    super.onRequest(options, handler);
  }
}

class ErrorInterceptor extends Interceptor {
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    if (err.response?.statusCode == 401) {
      print('Caught 401 Error. Token refresh logic would go here.');
    }
    super.onError(err, handler);
  }
}
```

#### **DataSource Template (`data/datasources/restaurant_remote_datasource.dart`)**
```dart
import 'package:dio/dio.dart';
import 'package:otlob/data/models/restaurant.dart';
import 'package:otlob/core/error/exceptions.dart';

abstract class RestaurantRemoteDataSource {
  Future<List<Restaurant>> getRestaurants();
}

class RestaurantRemoteDataSourceImpl implements RestaurantRemoteDataSource {
  final Dio dio;
  RestaurantRemoteDataSourceImpl({required this.dio});

  @override
  Future<List<Restaurant>> getRestaurants() async {
    try {
      final response = await dio.get('/restaurants');
      if (response.statusCode == 200 && response.data != null) {
        return (response.data as List)
            .map((json) => Restaurant.fromJson(json))
            .toList();
      } else {
        throw ServerException('Failed to load restaurants', statusCode: response.statusCode);
      }
    } on DioException catch (e) {
      throw ServerException(e.message ?? 'An unknown error occurred', statusCode: e.response?.statusCode);
    }
  }
}
```

#### **Testing the API Layer**
To unit test components that depend on a `DataSource`, we will use a mocking library (like `mockito`) to create a mock version of the `DataSource` interface.

---
### **Section 7: Routing (Revised)**

#### **Route Configuration (`app/router.dart`)**
```dart
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:async';

class GoRouterRefreshStream extends ChangeNotifier {
  GoRouterRefreshStream(Stream<dynamic> stream) {
    notifyListeners();
    _subscription = stream.asBroadcastStream().listen((_) => notifyListeners());
  }
  late final StreamSubscription<dynamic> _subscription;

  @override
  void dispose() {
    _subscription.cancel();
    super.dispose();
  }
}

class AppRouter {
  final AuthBloc authBloc;
  AppRouter(this.authBloc);

  late final GoRouter router = GoRouter(
    refreshListenable: GoRouterRefreshStream(authBloc.stream),
    
    routes: <RouteBase>[
      ShellRoute(
        builder: (context, state, child) {
          return Placeholder(child: child);
        },
        routes: [
          GoRoute(
            path: '/',
            pageBuilder: (context, state) => const NoTransitionPage(child: Placeholder()),
          ),
          GoRoute(
            path: '/orders',
            pageBuilder: (context, state) => const NoTransitionPage(child: Placeholder()),
          ),
        ],
      ),
      GoRoute(
        path: '/login',
        pageBuilder: (context, state) => const NoTransitionPage(child: Placeholder()),
      ),
      GoRoute(
        path: '/restaurant/:id',
        builder: (BuildContext context, GoRouterState state) {
          final restaurantId = state.pathParameters['id']!;
          return const Placeholder();
        },
      ),
    ],

    errorBuilder: (context, state) => const Text("404 - Not Found"),

    redirect: (BuildContext context, GoRouterState state) {
      final authState = authBloc.state;
      final bool loggedIn = authState is Authenticated;
      final bool isLoggingIn = state.matchedLocation == '/login';

      if (!loggedIn && !isLoggingIn) return '/login';
      if (loggedIn && isLoggingIn) return '/';
      
      return null;
    },
  );
}
```

#### **Testing Routes**
Every new route must be accompanied by a navigation test.

---
### **Section 8: Styling Guidelines (Revised)**

#### **Global Theme Definition (`app/theme.dart`)**
```dart
import 'package:flutter/material.dart';

@immutable
class AppThemeExtension extends ThemeExtension<AppThemeExtension> {
  const AppThemeExtension({ required this.spacing, required this.radii });
  final AppSpacing spacing;
  final AppRadii radii;
}

class AppSpacing {
  const AppSpacing({
    this.small = 8.0,
    this.medium = 16.0,
    this.large = 24.0,
  });
  final double small;
  final double medium;
  final double large;
}

class AppRadii {
  const AppRadii({
    this.small = const BorderRadius.all(Radius.circular(8.0)),
    this.medium = const BorderRadius.all(Radius.circular(12.0)),
  });
  final BorderRadius small;
  final BorderRadius medium;
}

class AppTheme {
  static final lightTheme = ThemeData(
    colorScheme: const ColorScheme.light(
      primary: Color(0xFF0D1B2A),
      secondary: Color(0xFFE07A5F),
      surface: Color(0xFFF8F9FA),
      background: Colors.white,
      error: Color(0xFFFF4136),
      tertiary: Color(0xFF3D9970), // Success
      inversePrimary: Color(0xFFFFDC00), // Warning
    ),
    textTheme: const TextTheme(
      displayMedium: TextStyle(fontFamily: 'Poppins', fontSize: 28, fontWeight: FontWeight.bold),
      headlineMedium: TextStyle(fontFamily: 'Poppins', fontSize: 24, fontWeight: FontWeight.w600),
      titleLarge: TextStyle(fontFamily: 'Roboto', fontSize: 22, fontWeight: FontWeight.w500),
      bodyLarge: TextStyle(fontFamily: 'Roboto', fontSize: 16),
      bodyMedium: TextStyle(fontFamily: 'Roboto', fontSize: 14),
      labelSmall: TextStyle(fontFamily: 'Roboto', fontSize: 12, letterSpacing: 0.5),
    ),
    extensions: <ThemeExtension<dynamic>>[
      const AppThemeExtension(
        spacing: AppSpacing(),
        radii: AppRadii(),
      ),
    ],
  );
}

extension CustomThemeContext on BuildContext {
  AppThemeExtension get customTheme => Theme.of(this).extension<AppThemeExtension>()!;
}
```

#### **Accessibility Considerations**
*   **Text Scaling:** The defined `TextTheme` must be tested to ensure it scales gracefully with `MediaQuery.textScaleFactor`.
*   **Contrast Ratios:** The color palette must be verified to meet WCAG AA contrast ratios.

---
### **Section 9: Testing Requirements (Revised)**

#### **Widget Test Template (`restaurant_card_test.dart`)**
```dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:otlob/shared_widgets/restaurant_card.dart';

void main() {
  testWidgets('RestaurantCard displays name and image', (WidgetTester tester) async {
    await tester.pumpWidget(
      const MaterialApp(
        home: Scaffold(
          body: RestaurantCard(
            name: 'Koshary El Tahrir',
            imageUrl: 'https://example.com/koshary.jpg',
          ),
        ),
      ),
    );
    expect(find.text('Koshary El Tahrir'), findsOneWidget);
    expect(find.byType(Image), findsOneWidget);
  });
}
```

#### **Testing Strategy & Best Practices**
*   **Unit Tests:** For all business logic in repositories, usecases, and BLoCs/Cubits.
*   **Widget Tests:** For all widgets to verify rendering and basic interactions.
*   **BLoC/Cubit Tests:** Use `bloc_test` to test all state transitions.
*   **Integration Tests:** For critical end-to-end user flows using `integration_test`.
*   **Golden Tests:** For key visual components to prevent UI regressions.
*   **Error & Edge Case Testing:** Tests must cover error states, empty states, and invalid inputs.

#### **Test Enforcement & CI/CD**
*   **Continuous Integration:** All tests must pass in the CI pipeline before any PR can be merged.
*   **Code Coverage:** Aim for a minimum of **80% test coverage** for all new code, tracked via CI.

---
### **Section 10: Environment Configuration (Revised)**

#### **Approach**
Use a multi-environment `.env` file strategy, managed by Flutter flavors (`.env.dev`, `.env.prod`).

#### **CI/CD & Secrets Management**
`.env` files will not be stored in CI. Secrets will be injected at build time from the CI system's secret store.

#### **Configuration Access & Validation (`core/config/config.dart`)**
```dart
import 'package:flutter/foundation.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';

class Config {
  static Future<void> load(String flavor) async {
    await dotenv.load(fileName: '.env.$flavor');
    _validate();
  }

  static void _validate() {
    final requiredKeys = ['API_BASE_URL'];
    for (final key in requiredKeys) {
      if (!dotenv.isInitialized || dotenv.env[key] == null) {
        throw Exception('FATAL: Missing required environment variable: $key');
      }
    }
  }

  static String get apiBaseUrl => dotenv.env['API_BASE_URL']!;
  static bool get useMockPayments => dotenv.env['USE_MOCK_PAYMENTS']?.toLowerCase() == 'true';
}
```

---
### **Section 11: Frontend Developer Standards**

#### **Critical Coding Rules**
1.  **State Management:** Use Cubit for simple state, BLoC for complex flows. State must be immutable.
2.  **Styling:** No hardcoded styles. Use `Theme.of(context)`.
3.  **API Calls:** Must go through the `Repository -> DataSource` abstraction.
4.  **Configuration:** Use the `Config` class.
5.  **Widgets:** Prefer `StatelessWidget` and `const`.
6.  **Testing:** All new features must have tests.
7.  **Null Safety:** No `!` operator.

#### **Quick Reference Guide**
*   **Commands:** `flutter run --flavor dev`, `flutter test --coverage`
*   **Imports:** Use absolute imports (`package:otlob/...`).
*   **Architecture:** UI -> BLoC -> Usecase -> Repository -> DataSource -> API

---
### **Section 12: Checklist Results Report**

**Checklist:** Frontend Architecture Validation
**Date:** 2025-09-27
**Validator:** Winston, Architect

| # | Section | Item | Status | Notes |
|---|---|---|---|---|
| 1 | Section 2 | Tech Stack Selection | COMPLETE | All technologies are well-justified and versions are specified. |
| 2 | Section 3 | Project Structure | COMPLETE | The structure is clean, scalable, and follows best practices. |
| 3 | Section 4 | Component Standards | COMPLETE | Naming conventions, state management, and styling rules are clear. |
| 4 | Section 5 | State Management | COMPLETE | Clear guidance on using Cubit vs. BLoC. Error handling is defined. |
| 5 | Section 6 | API Integration | COMPLETE | `dio` with interceptors is a solid choice. DataSource pattern is well-defined. |
| 6 | Section 7 | Routing | COMPLETE | `go_router` is configured with authentication and error handling. |
| 7 | Section 8 | Styling Guidelines | COMPLETE | A centralized theme with custom extensions is an excellent approach. |
| 8 | Section 9 | Testing Requirements | COMPLETE | Comprehensive testing strategy covering all levels of testing. |
| 9 | Section 10 | Environment Config | COMPLETE | `.env` files with flavors and a `Config` class is a robust solution. |
| 10 | Section 11 | Developer Standards | COMPLETE | Critical coding rules are summarized and clear. |

**Overall Status:** **`APPROVED`**

**Summary:** The frontend architecture is robust, scalable, and well-documented. All major aspects have been considered and defined. The project is ready to move to the development phase.

---
### **Section 13: Next Steps**

With the frontend architecture approved, the project will now transition to the development phase, following the BMad-Method workflow:

1.  **Document Sharding:**
    *   The `front-end-architecture.md` and `prd.md` documents will be sharded into smaller, manageable pieces. This will allow the development team to focus on specific parts of the system without being overwhelmed by the entire documentation.
    *   The `po` (Product Owner) agent will be responsible for this task.

2.  **Story Creation:**
    *   The `sm` (Scrum Master) agent will create user stories from the sharded documents. Each story will represent a small, implementable piece of functionality.
    *   Stories will be stored in the `docs/stories/` directory and will have a status of "Draft".

3.  **Sprint Planning & Execution:**
    *   The development team will review the user stories, estimate the effort, and plan the sprints.
    *   The development will follow the `SM -> Dev -> QA` cycle for each story:
        *   **SM:** Creates the story.
        *   **Dev:** Implements the story.
        *   **QA:** Reviews and tests the implementation.
    *   The status of the stories will be updated as they move through the development process (`Draft` -> `Approved` -> `InProgress` -> `Review` -> `Done`).

4.  **Developer Handoff:**
    *   The development team can now be onboarded. They should familiarize themselves with the `front-end-architecture.md` document, especially the developer standards in Section 11.
    *   The first task for the development team will be to set up the project and start working on the first approved user story.